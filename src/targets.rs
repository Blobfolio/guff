/*!
# Guff - Targets
*/

use crate::GuffError;
use fyi_msg::Msg;
use parcel_css::targets::Browsers;
use std::num::NonZeroU32;



// The data generated by build.rs.
include!(concat!(env!("OUT_DIR"), "/guff-browsers.rs"));



/// # Parse Browsers.
pub(super) fn parse_browsers(src: &[u8]) -> Result<Option<Browsers>, GuffError> {
	let s = std::str::from_utf8(src).map_err(|_| GuffError::Browsers)?;
	let mut out = Browsers::default();
	let mut any: bool = false;

	for line in s.split(',') {
		let (agent, major) = parse_override(line.trim())?;
		if let Some((p, m)) = parse_version(agent.set(), major) {
			any = true;
			Msg::custom(
				"Compatibility",
				13,
				&format!("Capped to {}\x1b[2m/\x1b[0m{}.", agent.as_str(), m)
			)
				.with_newline(true)
				.print();

			match agent {
				Agent::Android => { out.android.replace(p); },
				Agent::Chrome => { out.chrome.replace(p); },
				Agent::Edge => { out.edge.replace(p); },
				Agent::Firefox => { out.firefox.replace(p); },
				Agent::Ie => { out.ie.replace(p); },
				Agent::Ios => { out.ios_saf.replace(p); },
				Agent::Opera => { out.opera.replace(p); },
				Agent::Safari => { out.safari.replace(p); },
				Agent::Samsung => { out.samsung.replace(p); },
			}
		}
	}

	if any { Ok(Some(out)) }
	else { Ok(None) }
}



#[derive(Debug, Clone, Copy, Eq, Hash, PartialEq)]
/// # Agent Kind.
enum Agent {
	Android,
	Chrome,
	Edge,
	Firefox,
	Ie,
	Ios,
	Opera,
	Safari,
	Samsung,
}

impl TryFrom<&str> for Agent {
	type Error = GuffError;

	fn try_from(src: &str) -> Result<Self, Self::Error> {
		match src.trim() {
			"android" => Ok(Self::Android),
			"chrome" | "and_chr" => Ok(Self::Chrome),
			"edge" => Ok(Self::Edge),
			"firefox" | "and_ff" => Ok(Self::Firefox),
			"ie" => Ok(Self::Ie),
			"ios_saf" => Ok(Self::Ios),
			"opera" | "op_mob" => Ok(Self::Opera),
			"safari" => Ok(Self::Safari),
			"samsung" => Ok(Self::Samsung),
			maybe => {
				let alt = maybe.to_ascii_lowercase();
				if alt == maybe { Err(GuffError::Browser(alt)) }
				else { Self::try_from(alt.as_str()) }
			},
		}
	}
}

impl Agent {
	/// # As Str.
	const fn as_str(self) -> &'static str {
		match self {
			Self::Android => "Android",
			Self::Chrome => "Chrome",
			Self::Edge => "Edge",
			Self::Firefox => "Firefox",
			Self::Ie => "IE",
			Self::Ios => "iOS",
			Self::Opera => "Opera",
			Self::Safari => "Safari",
			Self::Samsung => "Samsung",
		}
	}

	/// # Set.
	const fn set(self) -> &'static [(u32, u32)] {
		match self {
			Self::Android => &ANDROID,
			Self::Chrome => &CHROME,
			Self::Edge => &EDGE,
			Self::Firefox => &FIREFOX,
			Self::Ie => &IE,
			Self::Ios => &IOS,
			Self::Opera => &OPERA,
			Self::Safari => &SAFARI,
			Self::Samsung => &SAMSUNG,
		}
	}
}



/// # Parse Override.
fn parse_override(src: &str) -> Result<(Agent, Option<NonZeroU32>), GuffError> {
	let mut split = src.split_ascii_whitespace().take(2);

	// The agent has to be valid.
	let agent = split.next().ok_or_else(|| GuffError::Browser("[None]".to_owned()))?;
	let agent = Agent::try_from(agent)?;

	// Missing/invalid major versions just turn off filtering.
	let major = split.next().and_then(|s| s.parse::<NonZeroU32>().ok());
	Ok((agent, major))
}

/// # Parse Version Specific.
fn parse_version(set: &[(u32, u32)], version: Option<NonZeroU32>)
-> Option<(u32, u32)> {
	version
		.map(NonZeroU32::get)
		.and_then(|major| set.iter().rfind(|(_, m)| *m == major).copied())
}
