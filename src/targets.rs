/*!
# Guff - Targets
*/

use parcel_css::targets::Browsers;
use std::num::{
	NonZeroU8,
	NonZeroU32,
};



// The data; generated by build.rs.
include!(concat!(env!("OUT_DIR"), "/guff-browsers.rs"));



#[derive(Debug, Clone, Copy)]
/// # Browser Option.
///
/// Can be limited by date and/or the latest X number of releases.
pub(super) enum BrowserOption {
	None,
	Major(NonZeroU32),
	Range(Option<NonZeroU8>, Option<NonZeroU8>) // Last X, Years
}

impl Default for BrowserOption {
	fn default() -> Self { Self::None }
}

impl BrowserOption {
	/// # Is Empty?
	const fn is_empty(self) -> bool {
		match self {
			Self::None => true,
			Self::Major(_) => false,
			Self::Range(l, y) => l.is_none() && y.is_none(),
		}
	}

	/// # Last/Age.
	pub(super) const fn range(last: u8, age: u8) -> Self {
		let last = NonZeroU8::new(last);
		let age = NonZeroU8::new(age);

		if last.is_some() || age.is_some() { Self::Range(last, age) }
		else { Self::None }
	}

	/// # Minimum Version.
	pub(super) const fn major(version: u32) -> Self {
		if let Some(x) = NonZeroU32::new(version) { Self::Major(x) }
		else { Self::None }
	}
}



#[derive(Debug, Clone, Copy)]
/// # Browser Options.
///
/// All the browsers, all the options.
pub(super) struct BrowserOptions([(Agent, BrowserOption); 9]);

impl Default for BrowserOptions {
	fn default() -> Self {
		Self([
			(Agent::Android, BrowserOption::None),
			(Agent::Chrome, BrowserOption::None),
			(Agent::Edge, BrowserOption::None),
			(Agent::Firefox, BrowserOption::None),
			(Agent::Ie, BrowserOption::None),
			(Agent::Ios, BrowserOption::None),
			(Agent::Opera, BrowserOption::None),
			(Agent::Safari, BrowserOption::None),
			(Agent::Samsung, BrowserOption::None),
		])
	}
}

impl From<BrowserOption> for BrowserOptions {
	fn from(opt: BrowserOption) -> Self {
		Self([
			(Agent::Android, opt),
			(Agent::Chrome, opt),
			(Agent::Edge, opt),
			(Agent::Firefox, opt),
			(Agent::Ie, BrowserOption::None),
			(Agent::Ios, opt),
			(Agent::Opera, opt),
			(Agent::Safari, opt),
			(Agent::Samsung, opt),
		])
	}
}

impl BrowserOptions {
	/// # Update Individual Browser.
	pub(super) fn set(&mut self, browser: Agent, opt: BrowserOption) {
		for line in &mut self.0 {
			if line.0 == browser {
				line.1 = opt;
				break;
			}
		}
	}

	/// # Into Browsers.
	///
	/// Crunch the settings into a `Browsers` object, unless nothing is set.
	pub(super) fn build(&self) -> Option<Browsers> {
		// Easy abort.
		if self.0.iter().all(|(_, o)| o.is_empty()) {
			return None;
		}

		let mut browsers = Browsers::default();
		let mut any: bool = false;
		for (agent, opt) in self.0 {
			if agent.set_version(opt, &mut browsers) {
				any = true;
			}
		}

		if any { Some(browsers) }
		else { None }
	}
}



#[derive(Debug, Clone, Copy, Eq, Hash, PartialEq)]
/// # Agent Kind.
pub(super) enum Agent {
	Android,
	Chrome,
	Edge,
	Firefox,
	Ie,
	Ios,
	Opera,
	Safari,
	Samsung,
}

impl Agent {
	/// # Get Version.
	fn get_version(self, opt: BrowserOption) -> Option<u32> {
		match opt {
			BrowserOption::Major(x) => {
				let versions: &[(u32, u32, u32)] = BROWSERS.iter()
					.find_map(|(a, v)|
						if *a == self { Some(*v) }
						else { None }
					)?;

				let x = x.get();
				versions.iter()
					.rfind(|(_, m, _)| *m == x)
					.map(|(p, _, _)| *p)
			},
			BrowserOption::Range(last, years) => {
				// Pull the versions.
				let mut versions: &[(u32, u32, u32)] = BROWSERS.iter()
					.find_map(|(a, v)|
						if *a == self { Some(*v) }
						else { None }
					)?;

				// Trim by last X.
				if let Some(last) = last {
					let last = usize::from(last.get());
					if last < versions.len() {
						versions = &versions[..last];
					}
				}

				// Trim by date.
				if let Some(years) = years {
					let min = utc2k::unixtime() - u32::from(years.get()) * utc2k::YEAR_IN_SECONDS;
					let trim = versions.iter()
						.take_while(|(_, _, d)| min <= *d)
						.count();
					if trim < versions.len() {
						versions = &versions[..trim];
					}
				}

				// Return the oldest of the remaining versions, if any.
				if versions.is_empty() { None }
				else { Some(versions[versions.len()].0) }
			},
			BrowserOption::None => None,
		}
	}

	/// # Set Version.
	fn set_version(self, opt: BrowserOption, browsers: &mut Browsers) -> bool {
		let browser = match self {
			Self::Android => &mut browsers.android,
			Self::Chrome => &mut browsers.chrome,
			Self::Edge => &mut browsers.edge,
			Self::Firefox => &mut browsers.firefox,
			Self::Ie => &mut browsers.ie,
			Self::Ios => &mut browsers.ios_saf,
			Self::Opera => &mut browsers.opera,
			Self::Safari => &mut browsers.safari,
			Self::Samsung => &mut browsers.samsung,
		};

		if let Some(version) = self.get_version(opt) {
			browser.replace(version);
			true
		}
		else if browser.is_some() {
			*browser = None;
			true
		}
		else { false }
	}
}
